define('@glimmer/util', ['exports', '@glimmer/env'], function (exports, env) { 'use strict';

    var EMPTY_ARRAY = Object.freeze([]);

    // import Logger from './logger';
    // let alreadyWarned = false;
    function debugAssert(test, msg) {
        // if (!alreadyWarned) {
        //   alreadyWarned = true;
        //   Logger.warn("Don't leave debug assertions on in public builds");
        // }
        if (!test) {
            throw new Error(msg || 'assertion failure');
        }
    }
    function deprecate(desc) {
        console.warn('DEPRECATION: ' + desc);
    }

    var GUID = 0;
    function initializeGuid(object) {
        return object._guid = ++GUID;
    }
    function ensureGuid(object) {
        return object._guid || initializeGuid(object);
    }

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    function dict() {
        return Object.create(null);
    }
    function isDict(u) {
        return u !== null && u !== undefined;
    }
    function isObject(u) {
        return typeof u === 'object' && u !== null;
    }
    var DictSet = function () {
        function DictSet() {
            _classCallCheck(this, DictSet);

            this.dict = dict();
        }

        DictSet.prototype.add = function add(obj) {
            if (typeof obj === 'string') this.dict[obj] = obj;else this.dict[ensureGuid(obj)] = obj;
            return this;
        };

        DictSet.prototype.delete = function _delete(obj) {
            if (typeof obj === 'string') delete this.dict[obj];else if (obj._guid) delete this.dict[obj._guid];
        };

        return DictSet;
    }();
    var StackImpl = function () {
        function StackImpl() {
            _classCallCheck(this, StackImpl);

            this.stack = [];
            this.current = null;
        }

        StackImpl.prototype.push = function push(item) {
            this.current = item;
            this.stack.push(item);
        };

        StackImpl.prototype.pop = function pop() {
            var item = this.stack.pop();
            var len = this.stack.length;
            this.current = len === 0 ? null : this.stack[len - 1];
            return item === undefined ? null : item;
        };

        StackImpl.prototype.nth = function nth(from) {
            var len = this.stack.length;
            return len < from ? null : this.stack[len - from];
        };

        StackImpl.prototype.isEmpty = function isEmpty() {
            return this.stack.length === 0;
        };

        StackImpl.prototype.toArray = function toArray() {
            return this.stack;
        };

        _createClass(StackImpl, [{
            key: 'size',
            get: function get() {
                return this.stack.length;
            }
        }]);

        return StackImpl;
    }();

    function keys(obj) {
        return Object.keys(obj);
    }
    function unwrap(val) {
        if (val === null || val === undefined) throw new Error('Expected value to be present');
        return val;
    }
    function expect(val, message) {
        if (val === null || val === undefined) throw new Error(message);
        return val;
    }
    function unreachable() {
        var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'unreachable';

        return new Error(message);
    }
    function exhausted(value) {
        throw new Error('Exhausted ' + value);
    }
    var tuple = function tuple() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return args;
    };
    var symbol = typeof Symbol !== 'undefined' ? Symbol : function (key) {
        return '__' + key + Math.floor(Math.random() * Date.now()) + '__';
    };

    var DESTROY = symbol('DESTROY');
    function isDestroyable(value) {
        return !!(value && value[DESTROY] !== undefined);
    }
    function isStringDestroyable(value) {
        return !!(value && typeof value === 'object' && typeof value.destroy === 'function');
    }

    function clearElement(parent) {
        var current = parent.firstChild;
        while (current) {
            var next = current.nextSibling;
            parent.removeChild(current);
            current = next;
        }
    }

    var SERIALIZATION_FIRST_NODE_STRING = '%+b:0%';
    function isSerializationFirstNode(node) {
        return node.nodeValue === SERIALIZATION_FIRST_NODE_STRING;
    }

    var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    var LINKED = new WeakMap();
    var WILL_DROP = symbol('WILL_DROP');
    var DID_DROP = symbol('DID_DROP');
    var CHILDREN = symbol('CHILDREN');
    var DESTRUCTORS = new WeakMap();
    function isDrop(value) {
        if (value === null || typeof value !== 'object') return false;
        return value[DID_DROP] !== undefined;
    }
    function associate(parent, child) {
        associateDestructor(parent, destructor(child));
    }
    function associateDestructor(parent, child) {
        var associated = LINKED.get(parent);
        if (!associated) {
            associated = new Set();
            LINKED.set(parent, associated);
        }
        associated.add(child);
    }
    function peekAssociated(parent) {
        return LINKED.get(parent) || null;
    }
    function takeAssociated(parent) {
        var linked = LINKED.get(parent);
        if (linked && linked.size > 0) {
            LINKED.delete(parent);
            return linked;
        } else {
            return null;
        }
    }
    function willDestroyAssociated(parent) {
        var associated = LINKED.get(parent);
        if (associated) {
            associated.forEach(function (item) {
                item[WILL_DROP]();
            });
        }
    }
    function didDestroyAssociated(parent) {
        var associated = LINKED.get(parent);
        if (associated) {
            associated.forEach(function (item) {
                item[DID_DROP]();
                associated.delete(item);
            });
        }
    }
    function destructor(value) {
        var d = DESTRUCTORS.get(value);
        if (!d) {
            if (isDestroyable(value)) {
                d = new DestroyableDestructor(value);
            } else if (isStringDestroyable(value)) {
                d = new StringDestroyableDestructor(value);
            } else {
                d = new SimpleDestructor(value);
            }
            DESTRUCTORS.set(value, d);
        }
        return d;
    }
    function snapshot(values) {
        return new SnapshotDestructor(values);
    }

    var SnapshotDestructor = function () {
        function SnapshotDestructor(destructors) {
            _classCallCheck$1(this, SnapshotDestructor);

            this.destructors = destructors;
        }

        SnapshotDestructor.prototype[WILL_DROP] = function () {
            this.destructors.forEach(function (item) {
                return item[WILL_DROP]();
            });
        };

        SnapshotDestructor.prototype[DID_DROP] = function () {
            this.destructors.forEach(function (item) {
                return item[DID_DROP]();
            });
        };

        SnapshotDestructor.prototype.toString = function toString() {
            return 'SnapshotDestructor';
        };

        _createClass$1(SnapshotDestructor, [{
            key: CHILDREN,
            get: function get() {
                return this.destructors;
            }
        }]);

        return SnapshotDestructor;
    }();

    var DestroyableDestructor = function () {
        function DestroyableDestructor(inner) {
            _classCallCheck$1(this, DestroyableDestructor);

            this.inner = inner;
        }

        DestroyableDestructor.prototype[WILL_DROP] = function () {
            willDestroyAssociated(this.inner);
        };

        DestroyableDestructor.prototype[DID_DROP] = function () {
            this.inner[DESTROY]();
            didDestroyAssociated(this.inner);
        };

        DestroyableDestructor.prototype.toString = function toString() {
            return 'DestroyableDestructor';
        };

        _createClass$1(DestroyableDestructor, [{
            key: CHILDREN,
            get: function get() {
                return LINKED.get(this.inner) || [];
            }
        }]);

        return DestroyableDestructor;
    }();

    var StringDestroyableDestructor = function () {
        function StringDestroyableDestructor(inner) {
            _classCallCheck$1(this, StringDestroyableDestructor);

            this.inner = inner;
        }

        StringDestroyableDestructor.prototype[WILL_DROP] = function () {
            if (typeof this.inner.willDestroy === 'function') {
                this.inner.willDestroy();
            }
            willDestroyAssociated(this.inner);
        };

        StringDestroyableDestructor.prototype[DID_DROP] = function () {
            this.inner.destroy();
            didDestroyAssociated(this.inner);
        };

        StringDestroyableDestructor.prototype.toString = function toString() {
            return 'StringDestroyableDestructor';
        };

        _createClass$1(StringDestroyableDestructor, [{
            key: CHILDREN,
            get: function get() {
                return LINKED.get(this.inner) || [];
            }
        }]);

        return StringDestroyableDestructor;
    }();

    var SimpleDestructor = function () {
        function SimpleDestructor(inner) {
            _classCallCheck$1(this, SimpleDestructor);

            this.inner = inner;
        }

        SimpleDestructor.prototype[WILL_DROP] = function () {
            willDestroyAssociated(this.inner);
        };

        SimpleDestructor.prototype[DID_DROP] = function () {
            didDestroyAssociated(this.inner);
        };

        SimpleDestructor.prototype.toString = function toString() {
            return 'SimpleDestructor';
        };

        _createClass$1(SimpleDestructor, [{
            key: CHILDREN,
            get: function get() {
                return LINKED.get(this.inner) || [];
            }
        }]);

        return SimpleDestructor;
    }();

    var ListContentsDestructor = function () {
        function ListContentsDestructor(inner) {
            _classCallCheck$1(this, ListContentsDestructor);

            this.inner = inner;
        }

        ListContentsDestructor.prototype[WILL_DROP] = function () {
            this.inner.forEachNode(function (d) {
                return destructor(d)[WILL_DROP]();
            });
        };

        ListContentsDestructor.prototype[DID_DROP] = function () {
            this.inner.forEachNode(function (d) {
                return destructor(d)[DID_DROP]();
            });
        };

        ListContentsDestructor.prototype.toString = function toString() {
            return 'ListContentsDestructor';
        };

        _createClass$1(ListContentsDestructor, [{
            key: CHILDREN,
            get: function get() {
                var out = [];
                this.inner.forEachNode(function (d) {
                    return out.push.apply(out, destructor(d)[CHILDREN]);
                });
                return out;
            }
        }]);

        return ListContentsDestructor;
    }();
    function debugDropTree(inner) {
        var hasDrop = isDrop(inner);
        var rawChildren = LINKED.get(inner) || null;
        var children = null;
        if (rawChildren) {
            children = [];
            for (var _iterator = rawChildren, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var child = _ref;

                children.push(debugDropTree(child));
            }
        }
        var obj = Object.create(null);
        obj.inner = inner;
        if (children) {
            obj.children = children;
        }
        obj.hasDrop = hasDrop;
        return obj;
    }
    function printDropTree(inner) {
        printDrop(destructor(inner));
    }
    function printDrop(inner) {
        console.group(String(inner));
        console.log(inner);
        var children = inner[CHILDREN] || null;
        if (children) {
            for (var _iterator2 = children, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
                var _ref2;

                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done) break;
                    _ref2 = _i2.value;
                }

                var child = _ref2;

                printDrop(child);
            }
        }
        console.groupEnd();
    }

    var _createClass$2 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    var ListNode = function ListNode(value) {
        _classCallCheck$2(this, ListNode);

        this.next = null;
        this.prev = null;
        this.value = value;
    };
    var LinkedList = function () {
        function LinkedList() {
            _classCallCheck$2(this, LinkedList);

            this.clear();
        }

        LinkedList.prototype.head = function head() {
            return this._head;
        };

        LinkedList.prototype.tail = function tail() {
            return this._tail;
        };

        LinkedList.prototype.clear = function clear() {
            this._head = this._tail = null;
        };

        LinkedList.prototype.toArray = function toArray() {
            var out = [];
            this.forEachNode(function (n) {
                return out.push(n);
            });
            return out;
        };

        LinkedList.prototype.nextNode = function nextNode(node) {
            return node.next;
        };

        LinkedList.prototype.forEachNode = function forEachNode(callback) {
            var node = this._head;
            while (node !== null) {
                callback(node);
                node = node.next;
            }
        };

        LinkedList.prototype.insertBefore = function insertBefore(node) {
            var reference = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            if (reference === null) return this.append(node);
            if (reference.prev) reference.prev.next = node;else this._head = node;
            node.prev = reference.prev;
            node.next = reference;
            reference.prev = node;
            return node;
        };

        LinkedList.prototype.append = function append(node) {
            var tail = this._tail;
            if (tail) {
                tail.next = node;
                node.prev = tail;
                node.next = null;
            } else {
                this._head = node;
            }
            return this._tail = node;
        };

        LinkedList.prototype.remove = function remove(node) {
            if (node.prev) node.prev.next = node.next;else this._head = node.next;
            if (node.next) node.next.prev = node.prev;else this._tail = node.prev;
            return node;
        };

        LinkedList.prototype[WILL_DROP] = function () {
            this.forEachNode(function (d) {
                return destructor(d)[WILL_DROP]();
            });
        };

        LinkedList.prototype[DID_DROP] = function () {
            this.forEachNode(function (d) {
                return destructor(d)[DID_DROP]();
            });
        };

        _createClass$2(LinkedList, [{
            key: CHILDREN,
            get: function get() {
                var out = [];
                this.forEachNode(function (d) {
                    return out.push.apply(out, destructor(d)[CHILDREN]);
                });
                return out;
            }
        }]);

        return LinkedList;
    }();
    var ListSlice = function () {
        function ListSlice(head, tail) {
            _classCallCheck$2(this, ListSlice);

            this._head = head;
            this._tail = tail;
        }

        ListSlice.prototype.forEachNode = function forEachNode(callback) {
            var node = this._head;
            while (node !== null) {
                callback(node);
                node = this.nextNode(node);
            }
        };

        ListSlice.prototype.head = function head() {
            return this._head;
        };

        ListSlice.prototype.tail = function tail() {
            return this._tail;
        };

        ListSlice.prototype.toArray = function toArray() {
            var out = [];
            this.forEachNode(function (n) {
                return out.push(n);
            });
            return out;
        };

        ListSlice.prototype.nextNode = function nextNode(node) {
            if (node === this._tail) return null;
            return node.next;
        };

        return ListSlice;
    }();
    var EMPTY_SLICE = new ListSlice(null, null);

    var objKeys = Object.keys;

    function assign(obj) {
        for (var i = 1; i < arguments.length; i++) {
            var assignment = arguments[i];
            if (assignment === null || typeof assignment !== 'object') continue;
            var keys = objKeys(assignment);
            for (var j = 0; j < keys.length; j++) {
                var key = keys[j];
                obj[key] = assignment[key];
            }
        }
        return obj;
    }
    function fillNulls(count) {
        var arr = new Array(count);
        for (var i = 0; i < count; i++) {
            arr[i] = null;
        }
        return arr;
    }
    function values(obj) {
        var vals = [];
        for (var key in obj) {
            vals.push(obj[key]);
        }
        return vals;
    }

    function strip(strings) {
        var out = '';

        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
        }

        for (var i = 0; i < strings.length; i++) {
            var string = strings[i];
            var dynamic = args[i] !== undefined ? String(args[i]) : '';
            out += '' + string + dynamic;
        }
        var lines = out.split('\n');
        while (lines.length && lines[0].match(/^\s*$/)) {
            lines.shift();
        }
        while (lines.length && lines[lines.length - 1].match(/^\s*$/)) {
            lines.pop();
        }
        var min = Infinity;
        for (var _iterator = lines, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var line = _ref;

            var leading = line.match(/^\s*/)[0].length;
            min = Math.min(min, leading);
        }
        var stripped = [];
        for (var _iterator2 = lines, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
            var _ref2;

            if (_isArray2) {
                if (_i2 >= _iterator2.length) break;
                _ref2 = _iterator2[_i2++];
            } else {
                _i2 = _iterator2.next();
                if (_i2.done) break;
                _ref2 = _i2.value;
            }

            var _line = _ref2;

            stripped.push(_line.slice(min));
        }
        return stripped.join('\n');
    }

    /**
     * Encodes a value that can be stored directly instead of being a handle.
     *
     * Immediates use the positive half of 32bits
     *
     * @param value - the value to be encoded.
     */
    function encodeImmediate(value) {
        if (typeof value === 'number') {
            // map -1 to -1073741820 onto 1073741828 to 2147483647
            // 1073741827 - (-1) == 1073741828
            // 1073741827 - (-1073741820) == 2147483647
            // positive it stays as is
            // 0 - 1073741823
            return value < 0 ? 1073741827 /* NEGATIVE_BASE */ - value : value;
        }
        if (value === false) {
            return 1073741824 /* FALSE */;
        }
        if (value === true) {
            return 1073741825 /* TRUE */;
        }
        if (value === null) {
            return 1073741826 /* NULL */;
        }
        if (value === undefined) {
            return 1073741827 /* UNDEFINED */;
        }
        return exhausted(value);
    }
    /**
     * Decodes an immediate into its value.
     *
     * @param value - the encoded immediate value
     */
    function decodeImmediate(value) {
        if (value > 1073741823 /* MAX_INT */) {
                switch (value) {
                    case 1073741824 /* FALSE */:
                        return false;
                    case 1073741825 /* TRUE */:
                        return true;
                    case 1073741826 /* NULL */:
                        return null;
                    case 1073741827 /* UNDEFINED */:
                        return undefined;
                    default:
                        // map 1073741828 to 2147483647 to -1 to -1073741820
                        // 1073741827 - 1073741828 == -1
                        // 1073741827 - 2147483647 == -1073741820
                        return 1073741827 /* NEGATIVE_BASE */ - value;
                }
            }
        return value;
    }
    /**
     * True if the number can be stored directly or false if it needs a handle.
     *
     * This is used on any number type to see if it can be directly encoded.
     */
    function isSmallInt(num) {
        return isInt(num, -1073741820 /* MIN_INT */, 1073741823 /* MAX_INT */);
    }
    /**
     * True if the encoded int32 operand or encoded stack int32 is a handle.
     */
    function isHandle(encoded) {
        return encoded < 0;
    }
    /**
     * Encodes an index to an operand or stack handle.
     */
    function encodeHandle(index) /* MAX_HANDLE */{
        var maxIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2147483647;
        var maxHandle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
        if (index > maxIndex) {
            throw new Error('index ' + index + ' overflowed range 0 to ' + maxIndex);
        }
        // -1 - 0 == -1
        // -1 - 1073741823 == -1073741824
        // -1073741825 - 0 == -1073741825
        // -1073741825 - 1073741823 == -2147483648
        return maxHandle - index;
    }
    /**
     * Decodes the index from the specified operand or stack handle.
     */
    function decodeHandle(handle) /* MAX_HANDLE */{
        var maxHandle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
        // -1 - -1 == 0
        // -1 - -1073741824 == 1073741823
        // -1073741825 - -1073741825 == 0
        // -1073741825 - -2147483648 == 1073741823
        return maxHandle - handle;
    }
    function isInt(num, min, max) {
        // this is the same as Math.floor(num) === num
        // also NaN % 1 is NaN and Infinity % 1 is NaN so both should fail
        return num % 1 === 0 && num >= min && num <= max;
    }

    var debugToString = void 0;
    if (env.DEBUG) {
        var getFunctionName = function getFunctionName(fn) {
            var functionName = fn.name;
            if (functionName === undefined) {
                var match = Function.prototype.toString.call(fn).match(/function (\w+)\s*\(/);
                functionName = match && match[1] || '';
            }
            return functionName.replace(/^bound /, '');
        };
        var getObjectName = function getObjectName(obj) {
            var name = void 0;
            var className = void 0;
            if (obj.constructor && obj.constructor !== Object) {
                className = getFunctionName(obj.constructor);
            }
            if ('toString' in obj && obj.toString !== Object.prototype.toString && obj.toString !== Function.prototype.toString) {
                name = obj.toString();
            }
            // If the class has a decent looking name, and the `toString` is one of the
            // default Ember toStrings, replace the constructor portion of the toString
            // with the class name. We check the length of the class name to prevent doing
            // this when the value is minified.
            if (name && name.match(/<.*:ember\d+>/) && className && className[0] !== '_' && className.length > 2 && className !== 'Class') {
                return name.replace(/<.*:/, '<' + className + ':');
            }
            return name || className;
        };
        var getPrimitiveName = function getPrimitiveName(value) {
            return String(value);
        };
        debugToString = function debugToString(value) {
            if (typeof value === 'function') {
                return getFunctionName(value) || '(unknown function)';
            } else if (typeof value === 'object' && value !== null) {
                return getObjectName(value) || '(unknown object)';
            } else {
                return getPrimitiveName(value);
            }
        };
    }
    var debugToString$1 = debugToString;

    function assertNever(value) {
        var desc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unexpected unreachable branch';

        console.log('unreachable', value);
        console.trace(desc + ' :: ' + JSON.stringify(value) + ' (' + value + ')');
    }

    exports.assertNever = assertNever;
    exports.EMPTY_ARRAY = EMPTY_ARRAY;
    exports.assert = debugAssert;
    exports.deprecate = deprecate;
    exports.dict = dict;
    exports.DictSet = DictSet;
    exports.isDict = isDict;
    exports.isObject = isObject;
    exports.Stack = StackImpl;
    exports.ensureGuid = ensureGuid;
    exports.initializeGuid = initializeGuid;
    exports.isSerializationFirstNode = isSerializationFirstNode;
    exports.SERIALIZATION_FIRST_NODE_STRING = SERIALIZATION_FIRST_NODE_STRING;
    exports.EMPTY_SLICE = EMPTY_SLICE;
    exports.LinkedList = LinkedList;
    exports.ListNode = ListNode;
    exports.ListSlice = ListSlice;
    exports.assign = assign;
    exports.fillNulls = fillNulls;
    exports.values = values;
    exports.debugToString = debugToString$1;
    exports.DESTROY = DESTROY;
    exports.isDestroyable = isDestroyable;
    exports.isStringDestroyable = isStringDestroyable;
    exports.clearElement = clearElement;
    exports.LINKED = LINKED;
    exports.WILL_DROP = WILL_DROP;
    exports.DID_DROP = DID_DROP;
    exports.CHILDREN = CHILDREN;
    exports.DESTRUCTORS = DESTRUCTORS;
    exports.isDrop = isDrop;
    exports.associate = associate;
    exports.associateDestructor = associateDestructor;
    exports.peekAssociated = peekAssociated;
    exports.takeAssociated = takeAssociated;
    exports.willDestroyAssociated = willDestroyAssociated;
    exports.didDestroyAssociated = didDestroyAssociated;
    exports.destructor = destructor;
    exports.snapshot = snapshot;
    exports.ListContentsDestructor = ListContentsDestructor;
    exports.debugDropTree = debugDropTree;
    exports.printDropTree = printDropTree;
    exports.printDrop = printDrop;
    exports.keys = keys;
    exports.unwrap = unwrap;
    exports.expect = expect;
    exports.unreachable = unreachable;
    exports.exhausted = exhausted;
    exports.tuple = tuple;
    exports.symbol = symbol;
    exports.strip = strip;
    exports.encodeImmediate = encodeImmediate;
    exports.decodeImmediate = decodeImmediate;
    exports.isSmallInt = isSmallInt;
    exports.isHandle = isHandle;
    exports.encodeHandle = encodeHandle;
    exports.decodeHandle = decodeHandle;

    Object.defineProperty(exports, '__esModule', { value: true });

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2xpbW1lci11dGlsLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9hcnJheS11dGlscy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2Fzc2VydC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2d1aWQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9jb2xsZWN0aW9ucy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL3BsYXRmb3JtLXV0aWxzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvdXRpbC9saWIvZGVzdHJveS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2RvbS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2lzLXNlcmlhbGl6YXRpb24tZmlyc3Qtbm9kZS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2xpZmV0aW1lcy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2xpc3QtdXRpbHMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9vYmplY3QtdXRpbHMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9zdHJpbmcudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9pbW1lZGlhdGUudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9kZWJ1Zy10by1zdHJpbmcudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBFTVBUWV9BUlJBWTogYW55W10gPSBPYmplY3QuZnJlZXplKFtdKSBhcyBhbnk7XG4iLCIvLyBpbXBvcnQgTG9nZ2VyIGZyb20gJy4vbG9nZ2VyJztcblxuLy8gbGV0IGFscmVhZHlXYXJuZWQgPSBmYWxzZTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRlYnVnQXNzZXJ0KHRlc3Q6IGFueSwgbXNnOiBzdHJpbmcpIHtcbiAgLy8gaWYgKCFhbHJlYWR5V2FybmVkKSB7XG4gIC8vICAgYWxyZWFkeVdhcm5lZCA9IHRydWU7XG4gIC8vICAgTG9nZ2VyLndhcm4oXCJEb24ndCBsZWF2ZSBkZWJ1ZyBhc3NlcnRpb25zIG9uIGluIHB1YmxpYyBidWlsZHNcIik7XG4gIC8vIH1cblxuICBpZiAoIXRlc3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdhc3NlcnRpb24gZmFpbHVyZScpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9kQXNzZXJ0KCkge31cblxuZXhwb3J0IGZ1bmN0aW9uIGRlcHJlY2F0ZShkZXNjOiBzdHJpbmcpIHtcbiAgY29uc29sZS53YXJuKGBERVBSRUNBVElPTjogJHtkZXNjfWApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBkZWJ1Z0Fzc2VydDtcbiIsImxldCBHVUlEID0gMDtcblxuZXhwb3J0IGludGVyZmFjZSBIYXNHdWlkIHtcbiAgX2d1aWQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVHdWlkKG9iamVjdDogSGFzR3VpZCk6IG51bWJlciB7XG4gIHJldHVybiAob2JqZWN0Ll9ndWlkID0gKytHVUlEKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUd1aWQob2JqZWN0OiBIYXNHdWlkKTogbnVtYmVyIHtcbiAgcmV0dXJuIG9iamVjdC5fZ3VpZCB8fCBpbml0aWFsaXplR3VpZChvYmplY3QpO1xufVxuIiwiaW1wb3J0IHsgSGFzR3VpZCwgZW5zdXJlR3VpZCB9IGZyb20gJy4vZ3VpZCc7XG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICcuL3BsYXRmb3JtLXV0aWxzJztcbmltcG9ydCB7IERpY3QsIFN0YWNrIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2V0PFQ+IHtcbiAgYWRkKHZhbHVlOiBUKTogU2V0PFQ+O1xuICBkZWxldGUodmFsdWU6IFQpOiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGljdDxUID0gdW5rbm93bj4oKTogRGljdDxUPiB7XG4gIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEaWN0PFQ+KHU6IFQpOiB1IGlzIERpY3QgJiBUIHtcbiAgcmV0dXJuIHUgIT09IG51bGwgJiYgdSAhPT0gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3Q8VD4odTogVCk6IHUgaXMgb2JqZWN0ICYgVCB7XG4gIHJldHVybiB0eXBlb2YgdSA9PT0gJ29iamVjdCcgJiYgdSAhPT0gbnVsbDtcbn1cblxuZXhwb3J0IHR5cGUgU2V0TWVtYmVyID0gSGFzR3VpZCB8IHN0cmluZztcblxuZXhwb3J0IGNsYXNzIERpY3RTZXQ8VCBleHRlbmRzIFNldE1lbWJlcj4gaW1wbGVtZW50cyBTZXQ8VD4ge1xuICBwcml2YXRlIGRpY3Q6IERpY3Q8VD47XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kaWN0ID0gZGljdDxUPigpO1xuICB9XG5cbiAgYWRkKG9iajogVCk6IFNldDxUPiB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB0aGlzLmRpY3Rbb2JqIGFzIGFueV0gPSBvYmo7XG4gICAgZWxzZSB0aGlzLmRpY3RbZW5zdXJlR3VpZChvYmogYXMgYW55KV0gPSBvYmo7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkZWxldGUob2JqOiBUKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSBkZWxldGUgdGhpcy5kaWN0W29iaiBhcyBhbnldO1xuICAgIGVsc2UgaWYgKChvYmogYXMgYW55KS5fZ3VpZCkgZGVsZXRlIHRoaXMuZGljdFsob2JqIGFzIGFueSkuX2d1aWRdO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTdGFja0ltcGw8VD4gaW1wbGVtZW50cyBTdGFjazxUPiB7XG4gIHByaXZhdGUgc3RhY2s6IFRbXSA9IFtdO1xuICBwdWJsaWMgY3VycmVudDogT3B0aW9uPFQ+ID0gbnVsbDtcblxuICBwdWJsaWMgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2subGVuZ3RoO1xuICB9XG5cbiAgcHVzaChpdGVtOiBUKSB7XG4gICAgdGhpcy5jdXJyZW50ID0gaXRlbTtcbiAgICB0aGlzLnN0YWNrLnB1c2goaXRlbSk7XG4gIH1cblxuICBwb3AoKTogT3B0aW9uPFQ+IHtcbiAgICBsZXQgaXRlbSA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgbGV0IGxlbiA9IHRoaXMuc3RhY2subGVuZ3RoO1xuICAgIHRoaXMuY3VycmVudCA9IGxlbiA9PT0gMCA/IG51bGwgOiB0aGlzLnN0YWNrW2xlbiAtIDFdO1xuXG4gICAgcmV0dXJuIGl0ZW0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBpdGVtO1xuICB9XG5cbiAgbnRoKGZyb206IG51bWJlcik6IE9wdGlvbjxUPiB7XG4gICAgbGV0IGxlbiA9IHRoaXMuc3RhY2subGVuZ3RoO1xuICAgIHJldHVybiBsZW4gPCBmcm9tID8gbnVsbCA6IHRoaXMuc3RhY2tbbGVuIC0gZnJvbV07XG4gIH1cblxuICBpc0VtcHR5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIHRvQXJyYXkoKTogVFtdIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjaztcbiAgfVxufVxuIiwiZXhwb3J0IHR5cGUgT3B0aW9uPFQ+ID0gVCB8IG51bGw7XG5leHBvcnQgdHlwZSBNYXliZTxUPiA9IE9wdGlvbjxUPiB8IHVuZGVmaW5lZCB8IHZvaWQ7XG5cbmV4cG9ydCB0eXBlIEZhY3Rvcnk8VD4gPSBuZXcgKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gVDtcblxuZXhwb3J0IGZ1bmN0aW9uIGtleXM8VD4ob2JqOiBUKTogQXJyYXk8a2V5b2YgVD4ge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKSBhcyBBcnJheTxrZXlvZiBUPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcDxUPih2YWw6IE1heWJlPFQ+KTogVCB7XG4gIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgdmFsdWUgdG8gYmUgcHJlc2VudGApO1xuICByZXR1cm4gdmFsIGFzIFQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBlY3Q8VD4odmFsOiBNYXliZTxUPiwgbWVzc2FnZTogc3RyaW5nKTogVCB7XG4gIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIHZhbCBhcyBUO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5yZWFjaGFibGUobWVzc2FnZSA9ICd1bnJlYWNoYWJsZScpOiBFcnJvciB7XG4gIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleGhhdXN0ZWQodmFsdWU6IG5ldmVyKTogbmV2ZXIge1xuICB0aHJvdyBuZXcgRXJyb3IoYEV4aGF1c3RlZCAke3ZhbHVlfWApO1xufVxuXG5leHBvcnQgdHlwZSBMaXQgPSBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgdW5kZWZpbmVkIHwgbnVsbCB8IHZvaWQgfCB7fTtcblxuZXhwb3J0IGNvbnN0IHR1cGxlID0gPFQgZXh0ZW5kcyBMaXRbXT4oLi4uYXJnczogVCkgPT4gYXJncztcblxuZXhwb3J0IGNvbnN0IHN5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnXG4gICAgPyBTeW1ib2xcbiAgICA6IChrZXk6IHN0cmluZykgPT4gYF9fJHtrZXl9JHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBEYXRlLm5vdygpKX1fX2AgYXMgYW55O1xuIiwiaW1wb3J0IHsgTWF5YmUsIFN5bWJvbERlc3Ryb3lhYmxlLCBEZXN0cm95YWJsZSwgRGVzdHJveVN5bWJvbCB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgc3ltYm9sIH0gZnJvbSAnLi9wbGF0Zm9ybS11dGlscyc7XG5cbmV4cG9ydCBjb25zdCBERVNUUk9ZOiBEZXN0cm95U3ltYm9sID0gc3ltYm9sKCdERVNUUk9ZJyk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Rlc3Ryb3lhYmxlKFxuICB2YWx1ZTogTWF5YmU8b2JqZWN0PiB8IFN5bWJvbERlc3Ryb3lhYmxlXG4pOiB2YWx1ZSBpcyBTeW1ib2xEZXN0cm95YWJsZSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiAodmFsdWUgYXMgU3ltYm9sRGVzdHJveWFibGUpW0RFU1RST1ldICE9PSB1bmRlZmluZWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmdEZXN0cm95YWJsZSh2YWx1ZTogTWF5YmU8UGFydGlhbDxEZXN0cm95YWJsZT4+KTogdmFsdWUgaXMgRGVzdHJveWFibGUge1xuICByZXR1cm4gISEodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG4iLCJpbXBvcnQgeyBPcHRpb24gfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFNpbXBsZUVsZW1lbnQsIFNpbXBsZU5vZGUgfSBmcm9tICdAc2ltcGxlLWRvbS9pbnRlcmZhY2UnO1xuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJFbGVtZW50KHBhcmVudDogU2ltcGxlRWxlbWVudCkge1xuICBsZXQgY3VycmVudDogT3B0aW9uPFNpbXBsZU5vZGU+ID0gcGFyZW50LmZpcnN0Q2hpbGQ7XG5cbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBsZXQgbmV4dCA9IGN1cnJlbnQubmV4dFNpYmxpbmc7XG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBuZXh0O1xuICB9XG59XG4iLCJpbXBvcnQgeyBTaW1wbGVOb2RlIH0gZnJvbSAnQHNpbXBsZS1kb20vaW50ZXJmYWNlJztcblxuZXhwb3J0IGNvbnN0IFNFUklBTElaQVRJT05fRklSU1RfTk9ERV9TVFJJTkcgPSAnJStiOjAlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2VyaWFsaXphdGlvbkZpcnN0Tm9kZShub2RlOiBTaW1wbGVOb2RlKTogYm9vbGVhbiB7XG4gIHJldHVybiBub2RlLm5vZGVWYWx1ZSA9PT0gU0VSSUFMSVpBVElPTl9GSVJTVF9OT0RFX1NUUklORztcbn1cbiIsImltcG9ydCB7IGlzRGVzdHJveWFibGUsIGlzU3RyaW5nRGVzdHJveWFibGUsIERFU1RST1kgfSBmcm9tICcuL2Rlc3Ryb3knO1xuaW1wb3J0IHtcbiAgT3B0aW9uLFxuICBTeW1ib2xEZXN0cm95YWJsZSxcbiAgRGVzdHJveWFibGUsXG4gIERyb3AsXG4gIFdpbGxEcm9wU3ltYm9sLFxuICBEaWREcm9wU3ltYm9sLFxuICBDaGlsZHJlblN5bWJvbCxcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBMaW5rZWRMaXN0LCBMaW5rZWRMaXN0Tm9kZSB9IGZyb20gJy4vbGlzdC11dGlscyc7XG5pbXBvcnQgeyBMT0NBTF9ERUJVRyB9IGZyb20gJ0BnbGltbWVyL2xvY2FsLWRlYnVnLWZsYWdzJztcbmltcG9ydCB7IHN5bWJvbCB9IGZyb20gJy4vcGxhdGZvcm0tdXRpbHMnO1xuXG5leHBvcnQgY29uc3QgTElOS0VEOiBXZWFrTWFwPG9iamVjdCwgU2V0PERyb3A+PiA9IG5ldyBXZWFrTWFwKCk7XG5leHBvcnQgY29uc3QgV0lMTF9EUk9QOiBXaWxsRHJvcFN5bWJvbCA9IHN5bWJvbCgnV0lMTF9EUk9QJyk7XG5leHBvcnQgY29uc3QgRElEX0RST1A6IERpZERyb3BTeW1ib2wgPSBzeW1ib2woJ0RJRF9EUk9QJyk7XG5leHBvcnQgY29uc3QgQ0hJTERSRU46IENoaWxkcmVuU3ltYm9sID0gc3ltYm9sKCdDSElMRFJFTicpO1xuZXhwb3J0IGNvbnN0IERFU1RSVUNUT1JTID0gbmV3IFdlYWtNYXAoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzRHJvcCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIERyb3Age1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gKHZhbHVlIGFzIERyb3ApW0RJRF9EUk9QXSAhPT0gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzb2NpYXRlKHBhcmVudDogb2JqZWN0LCBjaGlsZDogb2JqZWN0KSB7XG4gIGFzc29jaWF0ZURlc3RydWN0b3IocGFyZW50LCBkZXN0cnVjdG9yKGNoaWxkKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NvY2lhdGVEZXN0cnVjdG9yKHBhcmVudDogb2JqZWN0LCBjaGlsZDogRHJvcCk6IHZvaWQge1xuICBsZXQgYXNzb2NpYXRlZCA9IExJTktFRC5nZXQocGFyZW50KTtcblxuICBpZiAoIWFzc29jaWF0ZWQpIHtcbiAgICBhc3NvY2lhdGVkID0gbmV3IFNldCgpO1xuICAgIExJTktFRC5zZXQocGFyZW50LCBhc3NvY2lhdGVkKTtcbiAgfVxuXG4gIGFzc29jaWF0ZWQuYWRkKGNoaWxkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBlZWtBc3NvY2lhdGVkKHBhcmVudDogb2JqZWN0KTogT3B0aW9uPFNldDxEcm9wPj4ge1xuICByZXR1cm4gTElOS0VELmdldChwYXJlbnQpIHx8IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0YWtlQXNzb2NpYXRlZChwYXJlbnQ6IG9iamVjdCk6IE9wdGlvbjxTZXQ8RHJvcD4+IHtcbiAgbGV0IGxpbmtlZCA9IExJTktFRC5nZXQocGFyZW50KTtcblxuICBpZiAobGlua2VkICYmIGxpbmtlZC5zaXplID4gMCkge1xuICAgIExJTktFRC5kZWxldGUocGFyZW50KTtcbiAgICByZXR1cm4gbGlua2VkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aWxsRGVzdHJveUFzc29jaWF0ZWQocGFyZW50OiBvYmplY3QpIHtcbiAgbGV0IGFzc29jaWF0ZWQgPSBMSU5LRUQuZ2V0KHBhcmVudCk7XG5cbiAgaWYgKGFzc29jaWF0ZWQpIHtcbiAgICBhc3NvY2lhdGVkLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBpdGVtW1dJTExfRFJPUF0oKTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlkRGVzdHJveUFzc29jaWF0ZWQocGFyZW50OiBvYmplY3QpIHtcbiAgbGV0IGFzc29jaWF0ZWQgPSBMSU5LRUQuZ2V0KHBhcmVudCk7XG5cbiAgaWYgKGFzc29jaWF0ZWQpIHtcbiAgICBhc3NvY2lhdGVkLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBpdGVtW0RJRF9EUk9QXSgpO1xuICAgICAgYXNzb2NpYXRlZCEuZGVsZXRlKGl0ZW0pO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cnVjdG9yKHZhbHVlOiBvYmplY3QpOiBEcm9wIHtcbiAgbGV0IGQgPSBERVNUUlVDVE9SUy5nZXQodmFsdWUpO1xuXG4gIGlmICghZCkge1xuICAgIGlmIChpc0Rlc3Ryb3lhYmxlKHZhbHVlKSkge1xuICAgICAgZCA9IG5ldyBEZXN0cm95YWJsZURlc3RydWN0b3IodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmdEZXN0cm95YWJsZSh2YWx1ZSkpIHtcbiAgICAgIGQgPSBuZXcgU3RyaW5nRGVzdHJveWFibGVEZXN0cnVjdG9yKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZCA9IG5ldyBTaW1wbGVEZXN0cnVjdG9yKHZhbHVlKTtcbiAgICB9XG5cbiAgICBERVNUUlVDVE9SUy5zZXQodmFsdWUsIGQpO1xuICB9XG5cbiAgcmV0dXJuIGQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzbmFwc2hvdCh2YWx1ZXM6IFNldDxEcm9wPik6IERyb3Age1xuICByZXR1cm4gbmV3IFNuYXBzaG90RGVzdHJ1Y3Rvcih2YWx1ZXMpO1xufVxuXG5jbGFzcyBTbmFwc2hvdERlc3RydWN0b3IgaW1wbGVtZW50cyBEcm9wIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBkZXN0cnVjdG9yczogU2V0PERyb3A+KSB7fVxuXG4gIFtXSUxMX0RST1BdKCkge1xuICAgIHRoaXMuZGVzdHJ1Y3RvcnMuZm9yRWFjaChpdGVtID0+IGl0ZW1bV0lMTF9EUk9QXSgpKTtcbiAgfVxuXG4gIFtESURfRFJPUF0oKSB7XG4gICAgdGhpcy5kZXN0cnVjdG9ycy5mb3JFYWNoKGl0ZW0gPT4gaXRlbVtESURfRFJPUF0oKSk7XG4gIH1cblxuICBnZXQgW0NISUxEUkVOXSgpOiBJdGVyYWJsZTxEcm9wPiB7XG4gICAgcmV0dXJuIHRoaXMuZGVzdHJ1Y3RvcnM7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1NuYXBzaG90RGVzdHJ1Y3Rvcic7XG4gIH1cbn1cblxuY2xhc3MgRGVzdHJveWFibGVEZXN0cnVjdG9yIGltcGxlbWVudHMgRHJvcCB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaW5uZXI6IFN5bWJvbERlc3Ryb3lhYmxlKSB7fVxuXG4gIFtXSUxMX0RST1BdKCkge1xuICAgIHdpbGxEZXN0cm95QXNzb2NpYXRlZCh0aGlzLmlubmVyKTtcbiAgfVxuXG4gIFtESURfRFJPUF0oKSB7XG4gICAgdGhpcy5pbm5lcltERVNUUk9ZXSgpO1xuICAgIGRpZERlc3Ryb3lBc3NvY2lhdGVkKHRoaXMuaW5uZXIpO1xuICB9XG5cbiAgZ2V0IFtDSElMRFJFTl0oKTogSXRlcmFibGU8RHJvcD4ge1xuICAgIHJldHVybiBMSU5LRUQuZ2V0KHRoaXMuaW5uZXIpIHx8IFtdO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdEZXN0cm95YWJsZURlc3RydWN0b3InO1xuICB9XG59XG5cbmNsYXNzIFN0cmluZ0Rlc3Ryb3lhYmxlRGVzdHJ1Y3RvciBpbXBsZW1lbnRzIERyb3Age1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGlubmVyOiBEZXN0cm95YWJsZSkge31cblxuICBbV0lMTF9EUk9QXSgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuaW5uZXIud2lsbERlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuaW5uZXIud2lsbERlc3Ryb3koKTtcbiAgICB9XG4gICAgd2lsbERlc3Ryb3lBc3NvY2lhdGVkKHRoaXMuaW5uZXIpO1xuICB9XG5cbiAgW0RJRF9EUk9QXSgpIHtcbiAgICB0aGlzLmlubmVyLmRlc3Ryb3koKTtcbiAgICBkaWREZXN0cm95QXNzb2NpYXRlZCh0aGlzLmlubmVyKTtcbiAgfVxuXG4gIGdldCBbQ0hJTERSRU5dKCk6IEl0ZXJhYmxlPERyb3A+IHtcbiAgICByZXR1cm4gTElOS0VELmdldCh0aGlzLmlubmVyKSB8fCBbXTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnU3RyaW5nRGVzdHJveWFibGVEZXN0cnVjdG9yJztcbiAgfVxufVxuXG5jbGFzcyBTaW1wbGVEZXN0cnVjdG9yIGltcGxlbWVudHMgRHJvcCB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaW5uZXI6IG9iamVjdCkge31cblxuICBbV0lMTF9EUk9QXSgpIHtcbiAgICB3aWxsRGVzdHJveUFzc29jaWF0ZWQodGhpcy5pbm5lcik7XG4gIH1cblxuICBbRElEX0RST1BdKCkge1xuICAgIGRpZERlc3Ryb3lBc3NvY2lhdGVkKHRoaXMuaW5uZXIpO1xuICB9XG5cbiAgZ2V0IFtDSElMRFJFTl0oKTogSXRlcmFibGU8RHJvcD4ge1xuICAgIHJldHVybiBMSU5LRUQuZ2V0KHRoaXMuaW5uZXIpIHx8IFtdO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdTaW1wbGVEZXN0cnVjdG9yJztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTGlzdENvbnRlbnRzRGVzdHJ1Y3RvciBpbXBsZW1lbnRzIERyb3Age1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGlubmVyOiBMaW5rZWRMaXN0PExpbmtlZExpc3ROb2RlPikge31cblxuICBbV0lMTF9EUk9QXSgpIHtcbiAgICB0aGlzLmlubmVyLmZvckVhY2hOb2RlKGQgPT4gZGVzdHJ1Y3RvcihkKVtXSUxMX0RST1BdKCkpO1xuICB9XG5cbiAgW0RJRF9EUk9QXSgpIHtcbiAgICB0aGlzLmlubmVyLmZvckVhY2hOb2RlKGQgPT4gZGVzdHJ1Y3RvcihkKVtESURfRFJPUF0oKSk7XG4gIH1cblxuICBnZXQgW0NISUxEUkVOXSgpOiBJdGVyYWJsZTxEcm9wPiB7XG4gICAgbGV0IG91dDogRHJvcFtdID0gW107XG4gICAgdGhpcy5pbm5lci5mb3JFYWNoTm9kZShkID0+IG91dC5wdXNoKC4uLmRlc3RydWN0b3IoZClbQ0hJTERSRU5dKSk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnTGlzdENvbnRlbnRzRGVzdHJ1Y3Rvcic7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZWJ1Z05vZGUge1xuICBpbm5lcjogb2JqZWN0O1xuICBjaGlsZHJlbjogRGVidWdOb2RlW10gfCBudWxsO1xuICBoYXNEcm9wOiBib29sZWFuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVidWdEcm9wVHJlZShpbm5lcjogb2JqZWN0KTogRGVidWdOb2RlIHtcbiAgbGV0IGhhc0Ryb3AgPSBpc0Ryb3AoaW5uZXIpO1xuICBsZXQgcmF3Q2hpbGRyZW4gPSBMSU5LRUQuZ2V0KGlubmVyKSB8fCBudWxsO1xuICBsZXQgY2hpbGRyZW46IERlYnVnTm9kZVtdIHwgbnVsbCA9IG51bGw7XG5cbiAgaWYgKHJhd0NoaWxkcmVuKSB7XG4gICAgY2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKGxldCBjaGlsZCBvZiByYXdDaGlsZHJlbikge1xuICAgICAgY2hpbGRyZW4ucHVzaChkZWJ1Z0Ryb3BUcmVlKGNoaWxkKSk7XG4gICAgfVxuICB9XG5cbiAgbGV0IG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIG9iai5pbm5lciA9IGlubmVyO1xuICBpZiAoY2hpbGRyZW4pIHtcbiAgICBvYmouY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfVxuICBvYmouaGFzRHJvcCA9IGhhc0Ryb3A7XG4gIHJldHVybiBvYmo7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmludERyb3BUcmVlKGlubmVyOiBvYmplY3QpIHtcbiAgcHJpbnREcm9wKGRlc3RydWN0b3IoaW5uZXIpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByaW50RHJvcChpbm5lcjogRHJvcCkge1xuICBjb25zb2xlLmdyb3VwKFN0cmluZyhpbm5lcikpO1xuXG4gIGNvbnNvbGUubG9nKGlubmVyKTtcblxuICBsZXQgY2hpbGRyZW4gPSBpbm5lcltDSElMRFJFTl0gfHwgbnVsbDtcbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgIHByaW50RHJvcChjaGlsZCk7XG4gICAgfVxuICB9XG5cbiAgY29uc29sZS5ncm91cEVuZCgpO1xufVxuXG5pZiAoTE9DQUxfREVCVUcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgKHdpbmRvdyBhcyBhbnkpLlBSSU5UX0RST1AgPSBwcmludERyb3BUcmVlO1xufVxuIiwiaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnLi9wbGF0Zm9ybS11dGlscyc7XG5pbXBvcnQgeyBXSUxMX0RST1AsIERJRF9EUk9QLCBkZXN0cnVjdG9yLCBDSElMRFJFTiB9IGZyb20gJy4vbGlmZXRpbWVzJztcbmltcG9ydCB7IERyb3AgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcblxuZXhwb3J0IGludGVyZmFjZSBMaW5rZWRMaXN0Tm9kZSB7XG4gIG5leHQ6IE9wdGlvbjxMaW5rZWRMaXN0Tm9kZT47XG4gIHByZXY6IE9wdGlvbjxMaW5rZWRMaXN0Tm9kZT47XG59XG5cbmV4cG9ydCBjbGFzcyBMaXN0Tm9kZTxUPiBpbXBsZW1lbnRzIExpbmtlZExpc3ROb2RlIHtcbiAgcHVibGljIG5leHQ6IE9wdGlvbjxMaXN0Tm9kZTxUPj4gPSBudWxsO1xuICBwdWJsaWMgcHJldjogT3B0aW9uPExpc3ROb2RlPFQ+PiA9IG51bGw7XG4gIHB1YmxpYyB2YWx1ZTogVDtcblxuICBjb25zdHJ1Y3Rvcih2YWx1ZTogVCkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxufVxuXG4vLyB3ZSBhcmUgdW5hYmxlIHRvIGV4cHJlc3MgdGhlIGNvbnN0cmFpbnQgdGhhdCBUJ3MgLnByZXYgYW5kIC5uZXh0IGFyZVxuLy8gdGhlbXNlbHZlcyBULiBIb3dldmVyLCBpdCB3aWxsIGFsd2F5cyBiZSB0cnVlLCBzbyB0cnVzdCB1cy5cbnR5cGUgdHJ1c3QgPSBhbnk7XG5cbmV4cG9ydCBjbGFzcyBMaW5rZWRMaXN0PFQgZXh0ZW5kcyBMaW5rZWRMaXN0Tm9kZT4gaW1wbGVtZW50cyBTbGljZTxUPiwgRHJvcCB7XG4gIHByaXZhdGUgX2hlYWQhOiBPcHRpb248VD47XG4gIHByaXZhdGUgX3RhaWwhOiBPcHRpb248VD47XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jbGVhcigpO1xuICB9XG5cbiAgaGVhZCgpOiBPcHRpb248VD4ge1xuICAgIHJldHVybiB0aGlzLl9oZWFkO1xuICB9XG5cbiAgdGFpbCgpOiBPcHRpb248VD4ge1xuICAgIHJldHVybiB0aGlzLl90YWlsO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5faGVhZCA9IHRoaXMuX3RhaWwgPSBudWxsO1xuICB9XG5cbiAgdG9BcnJheSgpOiBUW10ge1xuICAgIGxldCBvdXQ6IFRbXSA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaE5vZGUobiA9PiBvdXQucHVzaChuKSk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIG5leHROb2RlKG5vZGU6IFQpOiBUIHtcbiAgICByZXR1cm4gbm9kZS5uZXh0IGFzIHRydXN0O1xuICB9XG5cbiAgZm9yRWFjaE5vZGUoY2FsbGJhY2s6IChub2RlOiBUKSA9PiB2b2lkKSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLl9oZWFkO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGNhbGxiYWNrKG5vZGUgYXMgdHJ1c3QpO1xuICAgICAgbm9kZSA9IG5vZGUubmV4dCBhcyB0cnVzdDtcbiAgICB9XG4gIH1cblxuICBpbnNlcnRCZWZvcmUobm9kZTogVCwgcmVmZXJlbmNlOiBPcHRpb248VD4gPSBudWxsKTogVCB7XG4gICAgaWYgKHJlZmVyZW5jZSA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuYXBwZW5kKG5vZGUpO1xuXG4gICAgaWYgKHJlZmVyZW5jZS5wcmV2KSByZWZlcmVuY2UucHJldi5uZXh0ID0gbm9kZTtcbiAgICBlbHNlIHRoaXMuX2hlYWQgPSBub2RlO1xuXG4gICAgbm9kZS5wcmV2ID0gcmVmZXJlbmNlLnByZXY7XG4gICAgbm9kZS5uZXh0ID0gcmVmZXJlbmNlO1xuICAgIHJlZmVyZW5jZS5wcmV2ID0gbm9kZTtcblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgYXBwZW5kKG5vZGU6IFQpOiBUIHtcbiAgICBsZXQgdGFpbCA9IHRoaXMuX3RhaWw7XG5cbiAgICBpZiAodGFpbCkge1xuICAgICAgdGFpbC5uZXh0ID0gbm9kZTtcbiAgICAgIG5vZGUucHJldiA9IHRhaWw7XG4gICAgICBub2RlLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oZWFkID0gbm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gKHRoaXMuX3RhaWwgPSBub2RlKTtcbiAgfVxuXG4gIHJlbW92ZShub2RlOiBUKTogVCB7XG4gICAgaWYgKG5vZGUucHJldikgbm9kZS5wcmV2Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgZWxzZSB0aGlzLl9oZWFkID0gbm9kZS5uZXh0IGFzIHRydXN0O1xuXG4gICAgaWYgKG5vZGUubmV4dCkgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7XG4gICAgZWxzZSB0aGlzLl90YWlsID0gbm9kZS5wcmV2IGFzIHRydXN0O1xuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBbV0lMTF9EUk9QXSgpIHtcbiAgICB0aGlzLmZvckVhY2hOb2RlKGQgPT4gZGVzdHJ1Y3RvcihkKVtXSUxMX0RST1BdKCkpO1xuICB9XG5cbiAgW0RJRF9EUk9QXSgpIHtcbiAgICB0aGlzLmZvckVhY2hOb2RlKGQgPT4gZGVzdHJ1Y3RvcihkKVtESURfRFJPUF0oKSk7XG4gIH1cblxuICBnZXQgW0NISUxEUkVOXSgpOiBJdGVyYWJsZTxEcm9wPiB7XG4gICAgbGV0IG91dDogRHJvcFtdID0gW107XG4gICAgdGhpcy5mb3JFYWNoTm9kZShkID0+IG91dC5wdXNoKC4uLmRlc3RydWN0b3IoZClbQ0hJTERSRU5dKSk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWNlPFQgZXh0ZW5kcyBMaW5rZWRMaXN0Tm9kZT4ge1xuICBoZWFkKCk6IE9wdGlvbjxUPjtcbiAgdGFpbCgpOiBPcHRpb248VD47XG4gIG5leHROb2RlKG5vZGU6IFQpOiBPcHRpb248VD47XG4gIGZvckVhY2hOb2RlKGNhbGxiYWNrOiAobm9kZTogVCkgPT4gdm9pZCk6IHZvaWQ7XG4gIHRvQXJyYXkoKTogVFtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENsb25lYWJsZUxpc3ROb2RlIGV4dGVuZHMgTGlua2VkTGlzdE5vZGUge1xuICBjbG9uZSgpOiB0aGlzO1xufVxuXG5leHBvcnQgY2xhc3MgTGlzdFNsaWNlPFQgZXh0ZW5kcyBMaW5rZWRMaXN0Tm9kZT4gaW1wbGVtZW50cyBTbGljZTxUPiB7XG4gIHByaXZhdGUgX2hlYWQ6IE9wdGlvbjxUPjtcbiAgcHJpdmF0ZSBfdGFpbDogT3B0aW9uPFQ+O1xuXG4gIGNvbnN0cnVjdG9yKGhlYWQ6IE9wdGlvbjxUPiwgdGFpbDogT3B0aW9uPFQ+KSB7XG4gICAgdGhpcy5faGVhZCA9IGhlYWQ7XG4gICAgdGhpcy5fdGFpbCA9IHRhaWw7XG4gIH1cblxuICBmb3JFYWNoTm9kZShjYWxsYmFjazogKG5vZGU6IFQpID0+IHZvaWQpIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMuX2hlYWQ7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2sobm9kZSk7XG4gICAgICBub2RlID0gdGhpcy5uZXh0Tm9kZShub2RlKTtcbiAgICB9XG4gIH1cblxuICBoZWFkKCk6IE9wdGlvbjxUPiB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWQ7XG4gIH1cblxuICB0YWlsKCk6IE9wdGlvbjxUPiB7XG4gICAgcmV0dXJuIHRoaXMuX3RhaWw7XG4gIH1cblxuICB0b0FycmF5KCk6IFRbXSB7XG4gICAgbGV0IG91dDogVFtdID0gW107XG4gICAgdGhpcy5mb3JFYWNoTm9kZShuID0+IG91dC5wdXNoKG4pKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgbmV4dE5vZGUobm9kZTogVCk6IE9wdGlvbjxUPiB7XG4gICAgaWYgKG5vZGUgPT09IHRoaXMuX3RhaWwpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBub2RlLm5leHQgYXMgVDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgRU1QVFlfU0xJQ0UgPSBuZXcgTGlzdFNsaWNlKG51bGwsIG51bGwpO1xuIiwiY29uc3QgeyBrZXlzOiBvYmpLZXlzIH0gPSBPYmplY3Q7XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ248VCwgVT4ob2JqOiBULCBhc3NpZ25tZW50czogVSk6IFQgJiBVO1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbjxULCBVLCBWPihvYmo6IFQsIGE6IFUsIGI6IFYpOiBUICYgVSAmIFY7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduPFQsIFUsIFYsIFc+KG9iajogVCwgYTogVSwgYjogViwgYzogVyk6IFQgJiBVICYgViAmIFc7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduPFQsIFUsIFYsIFcsIFg+KG9iajogVCwgYTogVSwgYjogViwgYzogVywgZDogWCk6IFQgJiBVICYgViAmIFcgJiBYO1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbjxULCBVLCBWLCBXLCBYLCBZPihcbiAgb2JqOiBULFxuICBhOiBVLFxuICBiOiBWLFxuICBjOiBXLFxuICBkOiBYLFxuICBlOiBZXG4pOiBUICYgVSAmIFYgJiBXICYgWCAmIFk7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduPFQsIFUsIFYsIFcsIFgsIFksIFo+KFxuICBvYmo6IFQsXG4gIGE6IFUsXG4gIGI6IFYsXG4gIGM6IFcsXG4gIGQ6IFgsXG4gIGU6IFksXG4gIGY6IFpcbik6IFQgJiBVICYgViAmIFcgJiBYICYgWSAmIFo7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKHRhcmdldDogYW55LCAuLi5hcmdzOiBhbnlbXSk6IGFueTtcbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24ob2JqOiBhbnkpIHtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgYXNzaWdubWVudCA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAoYXNzaWdubWVudCA9PT0gbnVsbCB8fCB0eXBlb2YgYXNzaWdubWVudCAhPT0gJ29iamVjdCcpIGNvbnRpbnVlO1xuICAgIGxldCBrZXlzID0gb2JqS2V5cyhhc3NpZ25tZW50KTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGxldCBrZXkgPSBrZXlzW2pdO1xuICAgICAgb2JqW2tleV0gPSBhc3NpZ25tZW50W2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWxsTnVsbHM8VD4oY291bnQ6IG51bWJlcik6IFRbXSB7XG4gIGxldCBhcnIgPSBuZXcgQXJyYXkoY291bnQpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgIGFycltpXSA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gYXJyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsdWVzPFQ+KG9iajogeyBbczogc3RyaW5nXTogVCB9KTogVFtdIHtcbiAgY29uc3QgdmFscyA9IFtdO1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICB2YWxzLnB1c2gob2JqW2tleV0pO1xuICB9XG4gIHJldHVybiB2YWxzO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIHN0cmlwKHN0cmluZ3M6IFRlbXBsYXRlU3RyaW5nc0FycmF5LCAuLi5hcmdzOiB1bmtub3duW10pIHtcbiAgbGV0IG91dCA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgc3RyaW5nID0gc3RyaW5nc1tpXTtcbiAgICBsZXQgZHluYW1pYyA9IGFyZ3NbaV0gIT09IHVuZGVmaW5lZCA/IFN0cmluZyhhcmdzW2ldKSA6ICcnO1xuXG4gICAgb3V0ICs9IGAke3N0cmluZ30ke2R5bmFtaWN9YDtcbiAgfVxuXG4gIGxldCBsaW5lcyA9IG91dC5zcGxpdCgnXFxuJyk7XG5cbiAgd2hpbGUgKGxpbmVzLmxlbmd0aCAmJiBsaW5lc1swXS5tYXRjaCgvXlxccyokLykpIHtcbiAgICBsaW5lcy5zaGlmdCgpO1xuICB9XG5cbiAgd2hpbGUgKGxpbmVzLmxlbmd0aCAmJiBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5tYXRjaCgvXlxccyokLykpIHtcbiAgICBsaW5lcy5wb3AoKTtcbiAgfVxuXG4gIGxldCBtaW4gPSBJbmZpbml0eTtcblxuICBmb3IgKGxldCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgbGV0IGxlYWRpbmcgPSBsaW5lLm1hdGNoKC9eXFxzKi8pIVswXS5sZW5ndGg7XG5cbiAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGxlYWRpbmcpO1xuICB9XG5cbiAgbGV0IHN0cmlwcGVkID0gW107XG5cbiAgZm9yIChsZXQgbGluZSBvZiBsaW5lcykge1xuICAgIHN0cmlwcGVkLnB1c2gobGluZS5zbGljZShtaW4pKTtcbiAgfVxuXG4gIHJldHVybiBzdHJpcHBlZC5qb2luKCdcXG4nKTtcbn1cbiIsImltcG9ydCB7IGV4aGF1c3RlZCB9IGZyb20gJy4vcGxhdGZvcm0tdXRpbHMnO1xuaW1wb3J0IHsgTE9DQUxfREVCVUcgfSBmcm9tICdAZ2xpbW1lci9sb2NhbC1kZWJ1Zy1mbGFncyc7XG5cbmxldCBjaGVja0ludDogdW5kZWZpbmVkIHwgKChudW06IG51bWJlciwgbWluPzogbnVtYmVyLCBtYXg/OiBudW1iZXIpID0+IHZvaWQpO1xuXG5pZiAoTE9DQUxfREVCVUcpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhcix2YXJzLW9uLXRvcFxuICBjaGVja0ludCA9IChudW06IG51bWJlciwgbWluID0gLTIxNDc0ODM2NDgsIG1heCA9IDIxNDc0ODM2NDcpID0+IHtcbiAgICBpZiAoIWlzSW50KG51bSwgbWluLCBtYXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7bnVtfSB0byBiZSBhbiBpbnRlZ2VyIGJldHdlZW4gJHttaW59IHRvICR7bWF4fWApO1xuICAgIH1cbiAgfTtcbn1cblxuLypcbkVuY29kaW5nIG5vdGVzXG5cbmZpcnN0XG4yIGJpdHMgICAgc3RhcnQgICAgICAgIGVuZFxuMCAxICAgICAgIDEwNzM3NDE4MjQgICAyMTQ3NDgzNjQ3ICAgZGlyZWN0IG5lZ2F0aXZlIG9yIGJvb2xlYW4gb3IgbnVsbCBvciB1bmRlZmluZWRcbjAgMCAgICAgICAwICAgICAgICAgICAgMTA3Mzc0MTgyMyAgIGRpcmVjdCBwb3NpdGl2ZVxuMSAxICAgICAgIC0xICAgICAgICAgICAtMTA3Mzc0MTgyNCAgc3RyaW5nIGluZGV4XG4xIDAgICAgICAgLTEwNzM3NDE4MjUgIC0yMTQ3NDgzNjQ4ICBudW1iZXIgaW5kZXhcblxuU2luY2UgZmlyc3QgYml0IGlzIHRoZSBzaWduIGJpdCB0aGVuXG5cbmVuY29kZWQgPj0gMCAgaXMgYWxsIGRpcmVjdGx5IGVuY29kZWQgdmFsdWVzXG5lbmNvZGVkIDwgMCAgaXMgYWxsIGluZGlyZWN0IGVuY29kZWQgdmFsdWVzIChlbmNvZGVkIGluZGV4ZXMpXG5cbkZvciBkaXJlY3RseSBlbmNvZGVkIHZhbHVlc1xuZW5jb2RlZCAgICAgIGRlY29kZWRcbjAgICAgICAgICAgICAwXG4uLi4gICAgICAgICAgLi4uXG4xMDczNzQxODIzICAgMTA3Mzc0MTgyM1xuMTA3Mzc0MTgyNCAgIGZhbHNlXG4xMDczNzQxODI1ICAgdHJ1ZVxuMTA3Mzc0MTgyNiAgIG51bGxcbjEwNzM3NDE4MjcgICB1bmRlZmluZWRcbjEwNzM3NDE4MjggICAtMVxuLi4uICAgICAgICAgIC4uLlxuMjE0NzQ4MzY0NyAgIC0xMDczNzQxODIwXG5cbmZvciBzdGFjayBoYW5kbGVzXG53ZSBtYXAganMgaW5kZXggMCB0byAyMTQ3NDgzNjQ3IG9udG8gLTEgdG8gLTIxNDc0ODM2NDhcblxuZm9yIGNvbnN0YW50IGhhbmRsZXNcbndlIG1hcCBzdHJpbmcgaW5kZXggMCB0byAxMDczNzQxODIzIG9udG8gLTEgdG8gLTEwNzM3NDE4MjRcbndlIG1hcCBudW1iZXIgaW5kZXggMCB0byAxMDczNzQxODIzIG9udG8gLTEwNzM3NDE4MjUgdG8gLTIxNDc0ODM2NDhcbiovXG5cbi8qKlxuICogSW1tZWRpYXRlcyB1c2UgdGhlIHBvc2l0aXZlIGhhbGYgb2YgMzIgYml0cyAwIHRocm91Z2ggMjE0NzQ4MzY0NyAoMHg3ZmZmZmZmZilcbiAqIGxlYXZpbmcgdGhlIG5lZ2F0aXZlIGhhbGYgZm9yIGhhbmRsZXMgLTEgdGhyb3VnaCAtMjE0NzQ4MzY0OC5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gSW1tZWRpYXRlQ29uc3RhbnRzIHtcbiAgLyoqXG4gICAqIDMxIGJpdHMgY2FuIGVuY29kZSAyXjMxIHZhbHVlc1xuICAgKi9cbiAgSU1NRURJQVRFX0xFTkdUSCA9IDIgKiogMzEsXG5cbiAgLyoqXG4gICAqIE1pbiBlbmNvZGVkIGltbWVkaWF0ZSBpcyBtaW4gcG9zaXRpdmVcbiAgICovXG4gIE1JTl9JTU1FRElBVEUgPSAwLFxuXG4gIC8qKlxuICAgKiBNYXggZW5jb2RlZCBpbW1lZGlhdGUgaXMgdGhlIG1heCBwb3NpdGl2ZSAzMiBiaXQgc2lnbmVkIGludFxuICAgKi9cbiAgTUFYX0lNTUVESUFURSA9IElNTUVESUFURV9MRU5HVEggLSAxLFxuXG4gIC8qKlxuICAgKiBUaGUgZW5jb2Rpbmcgb2YgZmFsc2UuXG4gICAqIEZhbHNlIGlzIHRoZSBzdGFydCBvZiB0aGUgc2Vjb25kIGhhbGYgb2YgMzEgYml0c1xuICAgKi9cbiAgRkFMU0UgPSBJTU1FRElBVEVfTEVOR1RIIC8gMixcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gaW50IHRoYXQgY2FuIGJlIGRpcmVjdGx5IGVuY29kZWQgdnMgYSBoYW5kbGUuXG4gICAqXG4gICAqIFRoZSBsYXN0IHBvc2l0aXZlIGludCBpcyBqdXN0IGJlZm9yZSBGQUxTRS5cbiAgICovXG4gIE1BWF9JTlQgPSBGQUxTRSAtIDEsXG5cbiAgLyoqXG4gICAqIFRoZSBlbmNvZGluZyBvZiB0cnVlXG4gICAqL1xuICBUUlVFID0gRkFMU0UgKyAxLFxuXG4gIC8qKlxuICAgKiBUaGUgZW5jb2Rpbmcgb2YgbnVsbFxuICAgKi9cbiAgTlVMTCA9IFRSVUUgKyAxLFxuXG4gIC8qKlxuICAgKiBUaGUgZW5jb2Rpbmcgb2YgdW5kZWZpbmVkXG4gICAqL1xuICBVTkRFRklORUQgPSBOVUxMICsgMSxcblxuICAvKipcbiAgICogRW5jb2RlZCAtMVxuICAgKlxuICAgKiBFbmNvZGVkIGp1c3QgYWZ0ZXIgVU5ERUZJTkVEXG4gICAqL1xuICBORUdBVElWRV9PTkUgPSBVTkRFRklORUQgKyAxLFxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSB0byBzdWJzdHJhY3QgYSBuZWdhdGl2ZSBmcm9tIHRvIGRlY29kZSBvciBlbmNvZGUgaXQuXG4gICAqXG4gICAqIE5FR0FUSVZFX09ORSAgICAgID09IE5FR0FUSVZFX0JBU0UgLSAtMSAgICAgICAgICAgICA9PSBlbmNvZGVJbW1lZGlhdGUoLTEpXG4gICAqIE1BWF9JTU1FRElBVEUgICAgID09IE5FR0FUSVZFX0JBU0UgLSBNSU5fSU5UICAgICAgICA9PSBlbmNvZGVJbW1lZGlhdGUoTUlOX0lOVClcbiAgICogLTEgICAgICAgICAgICAgICAgPT0gTkVHQVRJVkVfQkFTRSAtIE5FR0FUSVZFX09ORSAgID09IGRlY29kZUltbWVkaWF0ZShORUdBVElWRV9PTkUpXG4gICAqIE1JTl9JTlQgICAgICAgICAgID09IE5FR0FUSVZFX0JBU0UgLSBNQVhfSU1NRURJQVRFICA9PSBkZWNvZGVJbW1lZGlhdGUoTUFYX0lNTUVESUFURSlcbiAgICovXG4gIE5FR0FUSVZFX0JBU0UgPSBORUdBVElWRV9PTkUgLSAxLFxuXG4gIC8qKlxuICAgKiBUaGUgbWluaW11bSBpbnQgdGhhdCBjYW4gYmUgZGlyZWN0bHkgZW5jb2RlZCB2cyBhIGhhbmRsZS5cbiAgICovXG4gIE1JTl9JTlQgPSBORUdBVElWRV9CQVNFIC0gTUFYX0lNTUVESUFURSxcbn1cblxuLyoqXG4gKiBUaGUgY29tcGlsZXIgY29uc3RhbnRzIGRpdmlkZSB0aGUgaGFuZGxlcyBpbnRvIHR3byBoYWx2ZXMgc3RyaW5ncyBhbmQgbnVtYmVyc1xuICogd2hpbGUgb24gdGhlIHN0YWNrLCB0aGVyZSBpcyBvbmx5IG9uZSBhcnJheSBvZiBqcyB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBlbnVtIEhhbmRsZUNvbnN0YW50cyB7XG4gIEhBTkRMRV9MRU5HVEggPSAyICoqIDMxLFxuICBNQVhfSU5ERVggPSBIQU5ETEVfTEVOR1RIIC0gMSxcbiAgTUFYX0hBTkRMRSA9IC0xLFxuICBNSU5fSEFORExFID0gLTEgLSBNQVhfSU5ERVgsXG4gIFNUUklOR19IQU5ETEVfTEVOR1RIID0gSEFORExFX0xFTkdUSCAvIDIsXG4gIE5VTUJFUl9IQU5ETEVfTEVOR1RIID0gSEFORExFX0xFTkdUSCAtIFNUUklOR19IQU5ETEVfTEVOR1RILFxuICBTVFJJTkdfTUFYX0lOREVYID0gU1RSSU5HX0hBTkRMRV9MRU5HVEggLSAxLFxuICBOVU1CRVJfTUFYX0lOREVYID0gTlVNQkVSX0hBTkRMRV9MRU5HVEggLSAxLFxuICBTVFJJTkdfTUFYX0hBTkRMRSA9IE1BWF9IQU5ETEUsXG4gIFNUUklOR19NSU5fSEFORExFID0gU1RSSU5HX01BWF9IQU5ETEUgLSBTVFJJTkdfTUFYX0lOREVYLFxuICBOVU1CRVJfTUFYX0hBTkRMRSA9IFNUUklOR19NSU5fSEFORExFIC0gMSxcbiAgTlVNQkVSX01JTl9IQU5ETEUgPSBOVU1CRVJfTUFYX0hBTkRMRSAtIE5VTUJFUl9NQVhfSU5ERVgsXG59XG5cbi8qKlxuICogRW5jb2RlcyBhIHZhbHVlIHRoYXQgY2FuIGJlIHN0b3JlZCBkaXJlY3RseSBpbnN0ZWFkIG9mIGJlaW5nIGEgaGFuZGxlLlxuICpcbiAqIEltbWVkaWF0ZXMgdXNlIHRoZSBwb3NpdGl2ZSBoYWxmIG9mIDMyYml0c1xuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlSW1tZWRpYXRlKHZhbHVlOiBudWxsIHwgdW5kZWZpbmVkIHwgYm9vbGVhbiB8IG51bWJlcikge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGlmIChMT0NBTF9ERUJVRykge1xuICAgICAgY2hlY2tJbnQhKHZhbHVlLCBJbW1lZGlhdGVDb25zdGFudHMuTUlOX0lOVCwgSW1tZWRpYXRlQ29uc3RhbnRzLk1BWF9JTlQpO1xuICAgIH1cbiAgICAvLyBtYXAgLTEgdG8gLTEwNzM3NDE4MjAgb250byAxMDczNzQxODI4IHRvIDIxNDc0ODM2NDdcbiAgICAvLyAxMDczNzQxODI3IC0gKC0xKSA9PSAxMDczNzQxODI4XG4gICAgLy8gMTA3Mzc0MTgyNyAtICgtMTA3Mzc0MTgyMCkgPT0gMjE0NzQ4MzY0N1xuICAgIC8vIHBvc2l0aXZlIGl0IHN0YXlzIGFzIGlzXG4gICAgLy8gMCAtIDEwNzM3NDE4MjNcbiAgICByZXR1cm4gdmFsdWUgPCAwID8gSW1tZWRpYXRlQ29uc3RhbnRzLk5FR0FUSVZFX0JBU0UgLSB2YWx1ZSA6IHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gSW1tZWRpYXRlQ29uc3RhbnRzLkZBTFNFO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBJbW1lZGlhdGVDb25zdGFudHMuVFJVRTtcbiAgfVxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gSW1tZWRpYXRlQ29uc3RhbnRzLk5VTEw7XG4gIH1cbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gSW1tZWRpYXRlQ29uc3RhbnRzLlVOREVGSU5FRDtcbiAgfVxuICByZXR1cm4gZXhoYXVzdGVkKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGFuIGltbWVkaWF0ZSBpbnRvIGl0cyB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB0aGUgZW5jb2RlZCBpbW1lZGlhdGUgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUltbWVkaWF0ZSh2YWx1ZTogbnVtYmVyKTogbnVsbCB8IHVuZGVmaW5lZCB8IGJvb2xlYW4gfCBudW1iZXIge1xuICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICAvLyBleHBlY3RlZCB2YWx1ZSB0byBiZSBjaGVja2VkIGJlZm9yZSB0aGlzXG4gICAgY2hlY2tJbnQhKHZhbHVlLCBJbW1lZGlhdGVDb25zdGFudHMuTUlOX0lNTUVESUFURSwgSW1tZWRpYXRlQ29uc3RhbnRzLk1BWF9JTU1FRElBVEUpO1xuICB9XG4gIGlmICh2YWx1ZSA+IEltbWVkaWF0ZUNvbnN0YW50cy5NQVhfSU5UKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSBJbW1lZGlhdGVDb25zdGFudHMuRkFMU0U6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGNhc2UgSW1tZWRpYXRlQ29uc3RhbnRzLlRSVUU6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSBJbW1lZGlhdGVDb25zdGFudHMuTlVMTDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIEltbWVkaWF0ZUNvbnN0YW50cy5VTkRFRklORUQ6XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBtYXAgMTA3Mzc0MTgyOCB0byAyMTQ3NDgzNjQ3IHRvIC0xIHRvIC0xMDczNzQxODIwXG4gICAgICAgIC8vIDEwNzM3NDE4MjcgLSAxMDczNzQxODI4ID09IC0xXG4gICAgICAgIC8vIDEwNzM3NDE4MjcgLSAyMTQ3NDgzNjQ3ID09IC0xMDczNzQxODIwXG4gICAgICAgIHJldHVybiBJbW1lZGlhdGVDb25zdGFudHMuTkVHQVRJVkVfQkFTRSAtIHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgbnVtYmVyIGNhbiBiZSBzdG9yZWQgZGlyZWN0bHkgb3IgZmFsc2UgaWYgaXQgbmVlZHMgYSBoYW5kbGUuXG4gKlxuICogVGhpcyBpcyB1c2VkIG9uIGFueSBudW1iZXIgdHlwZSB0byBzZWUgaWYgaXQgY2FuIGJlIGRpcmVjdGx5IGVuY29kZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NtYWxsSW50KG51bTogbnVtYmVyKSB7XG4gIHJldHVybiBpc0ludChudW0sIEltbWVkaWF0ZUNvbnN0YW50cy5NSU5fSU5ULCBJbW1lZGlhdGVDb25zdGFudHMuTUFYX0lOVCk7XG59XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgZW5jb2RlZCBpbnQzMiBvcGVyYW5kIG9yIGVuY29kZWQgc3RhY2sgaW50MzIgaXMgYSBoYW5kbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0hhbmRsZShlbmNvZGVkOiBudW1iZXIpIHtcbiAgaWYgKExPQ0FMX0RFQlVHKSB7XG4gICAgLy8gd2UgZXhwZWN0IHRvIG9ubHkgdXNlIHRoaXMgbWV0aG9kIHdoZW4gd2UgYWxyZWFkeSBrbm93IGl0IGlzIGFuIGludDMyXG4gICAgLy8gYmVjYXVzZSBpdCB3YXMgZW5jb2RlZCBvciByZWFkIGZyb20gdGhlIEludDMyQXJyYXkgYnVmZmVyXG4gICAgY2hlY2tJbnQhKGVuY29kZWQpO1xuICB9XG4gIHJldHVybiBlbmNvZGVkIDwgMDtcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGFuIGluZGV4IHRvIGFuIG9wZXJhbmQgb3Igc3RhY2sgaGFuZGxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlSGFuZGxlKFxuICBpbmRleDogbnVtYmVyLFxuICBtYXhJbmRleDogbnVtYmVyID0gSGFuZGxlQ29uc3RhbnRzLk1BWF9JTkRFWCxcbiAgbWF4SGFuZGxlOiBudW1iZXIgPSBIYW5kbGVDb25zdGFudHMuTUFYX0hBTkRMRVxuKSB7XG4gIGlmIChMT0NBTF9ERUJVRykge1xuICAgIC8vIGV4cGVjdGVkIHRoZSBpbmRleCB0byBhbHJlYWR5IGJlIGEgcG9zaXRpdmUgaW50IGluZGV4IGZyb20gcHVzaGluZyB0aGUgdmFsdWVcbiAgICBjaGVja0ludCEoaW5kZXgsIDApO1xuICB9XG4gIGlmIChpbmRleCA+IG1heEluZGV4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbmRleCAke2luZGV4fSBvdmVyZmxvd2VkIHJhbmdlIDAgdG8gJHttYXhJbmRleH1gKTtcbiAgfVxuICAvLyAtMSAtIDAgPT0gLTFcbiAgLy8gLTEgLSAxMDczNzQxODIzID09IC0xMDczNzQxODI0XG4gIC8vIC0xMDczNzQxODI1IC0gMCA9PSAtMTA3Mzc0MTgyNVxuICAvLyAtMTA3Mzc0MTgyNSAtIDEwNzM3NDE4MjMgPT0gLTIxNDc0ODM2NDhcbiAgcmV0dXJuIG1heEhhbmRsZSAtIGluZGV4O1xufVxuXG4vKipcbiAqIERlY29kZXMgdGhlIGluZGV4IGZyb20gdGhlIHNwZWNpZmllZCBvcGVyYW5kIG9yIHN0YWNrIGhhbmRsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUhhbmRsZShoYW5kbGU6IG51bWJlciwgbWF4SGFuZGxlOiBudW1iZXIgPSBIYW5kbGVDb25zdGFudHMuTUFYX0hBTkRMRSkge1xuICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICAvLyB3ZSBleHBlY3QgdG8gYmUgZGVjb2RpbmcgYSBlbmNvZGVkIGludDMyIG9wZXJhbmQgb3IgZW5jb2RlZCBpbnQzMiBvbiB0aGUgc3RhY2tcbiAgICBjaGVja0ludCEoaGFuZGxlLCBIYW5kbGVDb25zdGFudHMuTUlOX0hBTkRMRSwgbWF4SGFuZGxlKTtcbiAgfVxuICAvLyAtMSAtIC0xID09IDBcbiAgLy8gLTEgLSAtMTA3Mzc0MTgyNCA9PSAxMDczNzQxODIzXG4gIC8vIC0xMDczNzQxODI1IC0gLTEwNzM3NDE4MjUgPT0gMFxuICAvLyAtMTA3Mzc0MTgyNSAtIC0yMTQ3NDgzNjQ4ID09IDEwNzM3NDE4MjNcbiAgcmV0dXJuIG1heEhhbmRsZSAtIGhhbmRsZTtcbn1cblxuZnVuY3Rpb24gaXNJbnQobnVtOiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIE1hdGguZmxvb3IobnVtKSA9PT0gbnVtXG4gIC8vIGFsc28gTmFOICUgMSBpcyBOYU4gYW5kIEluZmluaXR5ICUgMSBpcyBOYU4gc28gYm90aCBzaG91bGQgZmFpbFxuICByZXR1cm4gbnVtICUgMSA9PT0gMCAmJiBudW0gPj0gbWluICYmIG51bSA8PSBtYXg7XG59XG4iLCJpbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5cbmxldCBkZWJ1Z1RvU3RyaW5nOiB1bmRlZmluZWQgfCAoKHZhbHVlOiB1bmtub3duKSA9PiBzdHJpbmcpO1xuXG5pZiAoREVCVUcpIHtcbiAgbGV0IGdldEZ1bmN0aW9uTmFtZSA9IChmbjogRnVuY3Rpb24pID0+IHtcbiAgICBsZXQgZnVuY3Rpb25OYW1lID0gZm4ubmFtZTtcblxuICAgIGlmIChmdW5jdGlvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IG1hdGNoID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZm4pLm1hdGNoKC9mdW5jdGlvbiAoXFx3KylcXHMqXFwoLyk7XG5cbiAgICAgIGZ1bmN0aW9uTmFtZSA9IChtYXRjaCAmJiBtYXRjaFsxXSkgfHwgJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uTmFtZS5yZXBsYWNlKC9eYm91bmQgLywgJycpO1xuICB9O1xuXG4gIGxldCBnZXRPYmplY3ROYW1lID0gKG9iajogb2JqZWN0KSA9PiB7XG4gICAgbGV0IG5hbWU7XG4gICAgbGV0IGNsYXNzTmFtZTtcblxuICAgIGlmIChvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgICAgIGNsYXNzTmFtZSA9IGdldEZ1bmN0aW9uTmFtZShvYmouY29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICd0b1N0cmluZycgaW4gb2JqICYmXG4gICAgICBvYmoudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgJiZcbiAgICAgIG9iai50b1N0cmluZyAhPT0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgKSB7XG4gICAgICBuYW1lID0gb2JqLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGNsYXNzIGhhcyBhIGRlY2VudCBsb29raW5nIG5hbWUsIGFuZCB0aGUgYHRvU3RyaW5nYCBpcyBvbmUgb2YgdGhlXG4gICAgLy8gZGVmYXVsdCBFbWJlciB0b1N0cmluZ3MsIHJlcGxhY2UgdGhlIGNvbnN0cnVjdG9yIHBvcnRpb24gb2YgdGhlIHRvU3RyaW5nXG4gICAgLy8gd2l0aCB0aGUgY2xhc3MgbmFtZS4gV2UgY2hlY2sgdGhlIGxlbmd0aCBvZiB0aGUgY2xhc3MgbmFtZSB0byBwcmV2ZW50IGRvaW5nXG4gICAgLy8gdGhpcyB3aGVuIHRoZSB2YWx1ZSBpcyBtaW5pZmllZC5cbiAgICBpZiAoXG4gICAgICBuYW1lICYmXG4gICAgICBuYW1lLm1hdGNoKC88Lio6ZW1iZXJcXGQrPi8pICYmXG4gICAgICBjbGFzc05hbWUgJiZcbiAgICAgIGNsYXNzTmFtZVswXSAhPT0gJ18nICYmXG4gICAgICBjbGFzc05hbWUubGVuZ3RoID4gMiAmJlxuICAgICAgY2xhc3NOYW1lICE9PSAnQ2xhc3MnXG4gICAgKSB7XG4gICAgICByZXR1cm4gbmFtZS5yZXBsYWNlKC88Lio6LywgYDwke2NsYXNzTmFtZX06YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWUgfHwgY2xhc3NOYW1lO1xuICB9O1xuXG4gIGxldCBnZXRQcmltaXRpdmVOYW1lID0gKHZhbHVlOiBhbnkpID0+IHtcbiAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgfTtcblxuICBkZWJ1Z1RvU3RyaW5nID0gKHZhbHVlOiB1bmtub3duKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGdldEZ1bmN0aW9uTmFtZSh2YWx1ZSkgfHwgYCh1bmtub3duIGZ1bmN0aW9uKWA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZ2V0T2JqZWN0TmFtZSh2YWx1ZSkgfHwgYCh1bmtub3duIG9iamVjdClgO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0UHJpbWl0aXZlTmFtZSh2YWx1ZSk7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBkZWJ1Z1RvU3RyaW5nO1xuIiwiZXhwb3J0IHsgRU1QVFlfQVJSQVkgfSBmcm9tICcuL2xpYi9hcnJheS11dGlscyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFzc2VydCwgZGVwcmVjYXRlIH0gZnJvbSAnLi9saWIvYXNzZXJ0JztcbmV4cG9ydCB7IGRpY3QsIERpY3RTZXQsIGlzRGljdCwgaXNPYmplY3QsIFNldCwgU3RhY2tJbXBsIGFzIFN0YWNrIH0gZnJvbSAnLi9saWIvY29sbGVjdGlvbnMnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvZGVzdHJveSc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9kb20nO1xuZXhwb3J0IHsgZW5zdXJlR3VpZCwgSGFzR3VpZCwgaW5pdGlhbGl6ZUd1aWQgfSBmcm9tICcuL2xpYi9ndWlkJztcbmV4cG9ydCB7XG4gIGlzU2VyaWFsaXphdGlvbkZpcnN0Tm9kZSxcbiAgU0VSSUFMSVpBVElPTl9GSVJTVF9OT0RFX1NUUklORyxcbn0gZnJvbSAnLi9saWIvaXMtc2VyaWFsaXphdGlvbi1maXJzdC1ub2RlJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL2xpZmV0aW1lcyc7XG5leHBvcnQge1xuICBDbG9uZWFibGVMaXN0Tm9kZSxcbiAgRU1QVFlfU0xJQ0UsXG4gIExpbmtlZExpc3QsXG4gIExpbmtlZExpc3ROb2RlLFxuICBMaXN0Tm9kZSxcbiAgTGlzdFNsaWNlLFxuICBTbGljZSxcbn0gZnJvbSAnLi9saWIvbGlzdC11dGlscyc7XG5leHBvcnQgeyBhc3NpZ24sIGZpbGxOdWxscywgdmFsdWVzIH0gZnJvbSAnLi9saWIvb2JqZWN0LXV0aWxzJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL3BsYXRmb3JtLXV0aWxzJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL3N0cmluZyc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9pbW1lZGlhdGUnO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIGRlYnVnVG9TdHJpbmcgfSBmcm9tICcuL2xpYi9kZWJ1Zy10by1zdHJpbmcnO1xuXG5leHBvcnQgdHlwZSBGSVhNRTxULCBTIGV4dGVuZHMgc3RyaW5nPiA9IFQgJiBTIHwgVDtcblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE5ldmVyKHZhbHVlOiBuZXZlciwgZGVzYyA9ICd1bmV4cGVjdGVkIHVucmVhY2hhYmxlIGJyYW5jaCcpOiB2b2lkIHtcbiAgY29uc29sZS5sb2coJ3VucmVhY2hhYmxlJywgdmFsdWUpO1xuICBjb25zb2xlLnRyYWNlKGAke2Rlc2N9IDo6ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSAoJHt2YWx1ZX0pYCk7XG59XG4iXSwibmFtZXMiOlsiREVCVUciXSwibWFwcGluZ3MiOiI7O1FBQWEsY0FBcUIsT0FBQSxNQUFBLENBQTNCLEVBQTJCLENBQTNCOzs7SUNFUDtBQUVBLElBQU0sU0FBQSxXQUFBLENBQUEsSUFBQSxFQUFBLEdBQUEsRUFBNEM7SUFDaEQ7SUFDQTtJQUNBO0lBQ0E7SUFFQSxRQUFJLENBQUosSUFBQSxFQUFXO0lBQ1QsY0FBTSxJQUFBLEtBQUEsQ0FBVSxPQUFoQixtQkFBTSxDQUFOO0lBQ0Q7SUFDRjtBQUVELElBRU0sU0FBQSxTQUFBLENBQUEsSUFBQSxFQUFnQztJQUNwQyxZQUFBLElBQUEsbUJBQUEsSUFBQTtJQUNEOztJQ25CRCxJQUFJLE9BQUosQ0FBQTtBQU1BLElBQU0sU0FBQSxjQUFBLENBQUEsTUFBQSxFQUF3QztJQUM1QyxXQUFRLE9BQUEsS0FBQSxHQUFlLEVBQXZCLElBQUE7SUFDRDtBQUVELElBQU0sU0FBQSxVQUFBLENBQUEsTUFBQSxFQUFvQztJQUN4QyxXQUFPLE9BQUEsS0FBQSxJQUFnQixlQUF2QixNQUF1QixDQUF2QjtJQUNEOzs7OztJQ0hLLFNBQUEsSUFBQSxHQUFjO0lBQ2xCLFdBQU8sT0FBQSxNQUFBLENBQVAsSUFBTyxDQUFQO0lBQ0Q7QUFFRCxJQUFNLFNBQUEsTUFBQSxDQUFBLENBQUEsRUFBd0I7SUFDNUIsV0FBTyxNQUFBLElBQUEsSUFBYyxNQUFyQixTQUFBO0lBQ0Q7QUFFRCxJQUFNLFNBQUEsUUFBQSxDQUFBLENBQUEsRUFBMEI7SUFDOUIsV0FBTyxPQUFBLENBQUEsS0FBQSxRQUFBLElBQXlCLE1BQWhDLElBQUE7SUFDRDtBQUlELFFBQU0sT0FBTjtJQUdFLHVCQUFBO0lBQUE7O0lBQ0UsYUFBQSxJQUFBLEdBQUEs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